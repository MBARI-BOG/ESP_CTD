---
title: "ESP_CTD_beta_diversity"
author: "Markus Min"
date: "11/16/2021"
output: html_document
---


### Description
This Rmd contains the following beta diversity analyses:
1) DEICODE RPCA
2) Comparative analysis of paired ESP and CTD samples. This is in response to comments we received from Reviewer #2 that requested a more in-depth analysis of the correlation between paired samples.

In response to comments from the reviewers, all 2017 samples have been removed (COI and 16S). 


### Dependencies

In addition to the R packages required for this script, you will also need to install **qiime2** and **DEICODE** (a qiime2 plugin) and create a qiime2 environment to run DEICODE within.

### Load libraries
```{r}
library(tidyverse)
library(phyloseq)
library(qiime2R)
library(here)
library(vegan)
library(ggpubr)
library(egg)
library(rstatix)
```

### Load data

```{r}
#### COI
asv_table_path_COI <- here::here("data", "COI", "ESP_CTD_COI_asv_table.csv")
tax_table_path_COI <- here::here("data", "COI", "ESP_CTD_COI_tax_table.csv")
metadata_path_COI <- here::here("data", "COI", "ESP_CTD_COI_metadata.csv")

ESP_CTD_COI_phyloseq <- merge_phyloseq(otu_table(read.csv(asv_table_path_COI, row.names = 1),taxa_are_rows = TRUE),
                                       tax_table(as.matrix(read.csv(tax_table_path_COI, row.names = 1))),
                                       sample_data(read.csv(metadata_path_COI, row.names = 1)))

#### 18S
asv_table_path_18S <- here::here("data", "18S", "ESP_CTD_18S_asv_table.csv")
tax_table_path_18S <- here::here("data", "18S", "ESP_CTD_18S_tax_table.csv")
metadata_path_18S <- here::here("data", "18S", "ESP_CTD_18S_metadata.csv")

ESP_CTD_18S_phyloseq <- merge_phyloseq(otu_table(read.csv(asv_table_path_18S, row.names = 1),taxa_are_rows = TRUE),
                                       tax_table(as.matrix(read.csv(tax_table_path_18S, row.names = 1))),
                                       sample_data(read.csv(metadata_path_18S, row.names = 1)))

#### 12S
asv_table_path_12S <- here::here("data", "12S", "ESP_CTD_12S_asv_table.csv")
tax_table_path_12S <- here::here("data", "12S", "ESP_CTD_12S_tax_table.csv")
metadata_path_12S <- here::here("data", "12S", "ESP_CTD_12S_metadata.csv")

ESP_CTD_12S_phyloseq <- merge_phyloseq(otu_table(read.csv(asv_table_path_12S, row.names = 1),taxa_are_rows = TRUE),
                                       tax_table(as.matrix(read.csv(tax_table_path_12S, row.names = 1))),
                                       sample_data(read.csv(metadata_path_12S, row.names = 1)))

### 16S
# Read in combined taxonomy + ASV table
asv_tax_combined_path_16S <- here::here("data", "16S", "ESP_CTD_16S_dada2_table_with_tax.csv")
asv_tax_combined_16S <- read.csv(asv_tax_combined_path_16S)
# Split off asv table
dplyr::select(asv_tax_combined_16S, -Taxon) %>% 
  column_to_rownames("FeatureID") -> asv_table_16S
# Split off taxonomy, separate into fields per rank
tax_table_16S <- dplyr::select(asv_tax_combined_16S, FeatureID, Taxon)
tax_table_16S$Taxon <- gsub("[a-zA-Z]__","", tax_table_16S$Taxon)
tax_table_16S %>% separate(., Taxon, into = c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"), sep = ";") %>% 
  column_to_rownames("FeatureID") -> tax_table_16S
  
metadata_path_16S <- here::here("data", "16S", "ESP_CTD_16S_metadata.csv")

ESP_CTD_16S_phyloseq <- merge_phyloseq(otu_table(asv_table_16S,taxa_are_rows = TRUE),
                                       tax_table(as.matrix(tax_table_16S)),
                                       sample_data(read.csv(metadata_path_16S, row.names = 1)))

# Set figure directory
fig_dir <- here::here("resubmission")
```

# COI

### Prep data for DEICODE
```{r}
# Set directory for saving DEICODE data
deicode_dir <- here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission",  "COI")

# Subset environmental samples for comparison
ESP_CTD_COI_envt_phyloseq <- prune_samples(sample_data(ESP_CTD_COI_phyloseq)$CTD_or_ESP %in% c("CTD","ESP"),ESP_CTD_COI_phyloseq)
ESP_CTD_COI_envt_phyloseq <- prune_taxa(taxa_sums(ESP_CTD_COI_envt_phyloseq) > 0, ESP_CTD_COI_envt_phyloseq)

ESP_CTD_COI_envt_asv_table <- as.data.frame(as(otu_table(ESP_CTD_COI_envt_phyloseq),"matrix"))
ESP_CTD_COI_envt_asv_table <- tibble::rownames_to_column(ESP_CTD_COI_envt_asv_table,"#OTUID")
write.table(ESP_CTD_COI_envt_asv_table, paste0(deicode_dir, "/ESP_CTD_COI_envt_asv_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_COI_envt_tax_table <- as.data.frame(as(tax_table(ESP_CTD_COI_envt_phyloseq),"matrix"))
ESP_CTD_COI_envt_tax_table <- tibble::rownames_to_column(ESP_CTD_COI_envt_tax_table,"#OTUID")
write.table(ESP_CTD_COI_envt_tax_table,paste0(deicode_dir, "/ESP_CTD_COI_envt_tax_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_COI_envtsamples_metadata <- as.data.frame(as.matrix(sample_data(ESP_CTD_COI_envt_phyloseq)))
ESP_CTD_COI_envtsamples_metadata <- tibble::rownames_to_column(ESP_CTD_COI_envtsamples_metadata,"#SampleID")
# Add a categorical depth field to the metadata
ESP_CTD_COI_envtsamples_metadata %>%
  mutate(depth = as.numeric(depth)) %>%
  mutate(depth_cat = ifelse(depth <= 25.5, "0-25",
                            ifelse(depth <= 50, "27-50",
                                   ifelse(depth <= 201 & depth >=195, "195-200",
                                          "unknown")))) %>% 
  # Make another, simplified depth category (shallow_deep) 
  mutate(shallow_deep = ifelse(depth_cat %in% c("0-25", "27-50"), "shallow", "deep")) -> ESP_CTD_COI_envtsamples_metadata
write.table(ESP_CTD_COI_envtsamples_metadata, paste0(deicode_dir, "/ESP_CTD_COI_envt_sample_data_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
```


### Run DEICODE in Qiime2

```{bash, engine.opts = '-l', eval = FALSE}
# Enter qiime2 environment
conda activate qiime2-2020.11
pwd
#Make biom file
biom convert -i ../DEICODE/resubmission/COI/ESP_CTD_COI_envt_asv_table_for_biom.txt -o ../DEICODE/resubmission/COI/table.from_txt_json.biom --table-type="OTU table" --to-json
#add metadata files to biom file
biom add-metadata -i ../DEICODE/resubmission/COI/table.from_txt_json.biom -o ../DEICODE/resubmission/COI/table.w_md.biom \
--observation-metadata-fp ../DEICODE/resubmission/COI/ESP_CTD_COI_envt_tax_table_for_biom.txt \
--sample-metadata-fp ../DEICODE/resubmission/COI/ESP_CTD_COI_envt_sample_data_for_biom.txt

#import into Qiime2
qiime tools import \
 --input-path ../DEICODE/resubmission/COI/table.w_md.biom \
 --output-path ../DEICODE/resubmission/COI/ESP_CTD_COI_master.biom.qza \
 --type FeatureTable[Frequency]

#run DEICODE
qiime deicode rpca \
    --i-table ../DEICODE/resubmission/COI/ESP_CTD_COI_master.biom.qza \
    --p-n-components 3 \
    --p-min-feature-count 10 \
    --p-min-sample-count 1000 \
    --o-biplot ../DEICODE/resubmission/COI/ordination.qza \
    --o-distance-matrix ../DEICODE/resubmission/COI/distance.qza
```



### Run PERMANOVA
```{r }
# Extract metadata
pca_metadata <- ESP_CTD_COI_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load COI Data
distance <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "COI","distance.qza"))

# Extract distance matrix
distance_matrix <- distance$data

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

##----Run individual PERMANOVAs-------------------------------------------------------------

# PERMANOVA for CTD vs. ESP
ESP_CTD_permanova_COI <- adonis2(PCA_dist ~ CTD_or_ESP, data = pca_metadata, permutations=999)

# PERMANOVA for depth
depth_permanova_COI <- adonis2(PCA_dist ~ depth_cat, data = pca_metadata, permutations=999)

# PERMANOVA for seasonality (cruise)
season_permanova_COI <- adonis2(PCA_dist ~ SAMPLING_cruise, data = pca_metadata, permutations=999)

##----Run multi-factor PERMANOVAs-------------------------------------------------------------

# Multi-factorial PERMANOVA
mutli_permanova_COI <- adonis2(PCA_dist ~  shallow_deep + SAMPLING_cruise + CTD_or_ESP, data = pca_metadata, permutations=999)

# Save permanova value for plot - ESP vs. CTD after controlling for depth and cruise
permanova_value <- mutli_permanova_COI$`Pr(>F)`[3]
```


### Plot COI DEICODE RPCA
```{r}
pco <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "COI","ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_COI_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_COI_PCA <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ggsave(path = fig_dir, filename = "ESP_CTD_COI_PCA.png", ESP_CTD_COI_PCA,width = 7,height = 5)
```


### Plot COI DEICODE RPCA - with pairs labeled
```{r}
pco <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "COI","ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_COI_envtsamples_metadata

# Add a shortened label
pca_metadata %>% 
  mutate(ID_short = gsub("CN18", "", matching_ID)) -> pca_metadata


pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_COI_PCA_pairs_labeled <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  geom_line(lty = 2, aes(group = matching_ID)) +
  # geom_text(aes(label = ID_short)) +
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ggsave(path = fig_dir, filename = "ESP_CTD_COI_PCA_pairs_labeled.png", ESP_CTD_COI_PCA_pairs_labeled, width = 7,height = 5)
```


# 18S

### Prep data for DEICODE
```{r}
# Set directory for saving DEICODE data
deicode_dir <- here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission",  "18S")

# Subset environmental samples for comparison
ESP_CTD_18S_envt_phyloseq <- prune_samples(sample_data(ESP_CTD_18S_phyloseq)$CTD_or_ESP %in% c("CTD","ESP"),ESP_CTD_18S_phyloseq)
ESP_CTD_18S_envt_phyloseq <- prune_taxa(taxa_sums(ESP_CTD_18S_envt_phyloseq) > 0, ESP_CTD_18S_envt_phyloseq)

ESP_CTD_18S_envt_asv_table <- as.data.frame(as(otu_table(ESP_CTD_18S_envt_phyloseq),"matrix"))
ESP_CTD_18S_envt_asv_table <- tibble::rownames_to_column(ESP_CTD_18S_envt_asv_table,"#OTUID")
write.table(ESP_CTD_18S_envt_asv_table, paste0(deicode_dir, "/ESP_CTD_18S_envt_asv_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_18S_envt_tax_table <- as.data.frame(as(tax_table(ESP_CTD_18S_envt_phyloseq),"matrix"))
ESP_CTD_18S_envt_tax_table <- tibble::rownames_to_column(ESP_CTD_18S_envt_tax_table,"#OTUID")
write.table(ESP_CTD_18S_envt_tax_table, paste0(deicode_dir, "/ESP_CTD_18S_envt_tax_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_18S_envtsamples_metadata <- as.data.frame(as.matrix(sample_data(ESP_CTD_18S_envt_phyloseq)))
ESP_CTD_18S_envtsamples_metadata <- tibble::rownames_to_column(ESP_CTD_18S_envtsamples_metadata,"#SampleID")
# Add a categorical depth field to the metadata
ESP_CTD_18S_envtsamples_metadata %>%
  mutate(depth = as.numeric(depth)) %>%
  mutate(depth_cat = ifelse(depth <= 25.5, "0-25",
                            ifelse(depth <= 50, "27-50",
                                   ifelse(depth <= 201 & depth >=195, "195-200",
                                          "unknown"))))  %>% 
  # Make another, simplified depth category (shallow_deep) 
  mutate(shallow_deep = ifelse(depth_cat %in% c("0-25", "27-50"), "shallow", "deep")) -> ESP_CTD_18S_envtsamples_metadata
write.table(ESP_CTD_18S_envtsamples_metadata, paste0(deicode_dir, "/ESP_CTD_18S_envt_sample_data_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
```


### Run DEICODE in Qiime2

```{bash, engine.opts = '-l', eval = FALSE}
# Enter qiime2 environment
conda activate qiime2-2020.11

#Make biom file
biom convert -i ../DEICODE/resubmission/18S/ESP_CTD_18S_envt_asv_table_for_biom.txt -o ../DEICODE/resubmission/18S/table.from_txt_json.biom --table-type="OTU table" --to-json
#add metadata files to biom file
biom add-metadata -i ../DEICODE/resubmission/18S/table.from_txt_json.biom -o ../DEICODE/resubmission/18S/table.w_md.biom \
--observation-metadata-fp ../DEICODE/resubmission/18S/ESP_CTD_18S_envt_tax_table_for_biom.txt \
--sample-metadata-fp ../DEICODE/resubmission/18S/ESP_CTD_18S_envt_sample_data_for_biom.txt

#import into Qiime2
qiime tools import \
--input-path ../DEICODE/resubmission/18S/table.w_md.biom \
--output-path ../DEICODE/resubmission/18S/ESP_CTD_18S_master.biom.qza \
--type FeatureTable[Frequency]

#run DEICODE
qiime deicode rpca \
--i-table ../DEICODE/resubmission/18S/ESP_CTD_18S_master.biom.qza \
--p-n-components 3 \
--p-min-feature-count 10 \
--p-min-sample-count 1000 \
--o-biplot ../DEICODE/resubmission/18S/ordination.qza \
--o-distance-matrix ../DEICODE/resubmission/18S/distance.qza
```


### Run PERMANOVA
```{r }
# Extract metadata
pca_metadata <- ESP_CTD_18S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load 18S Data
distance <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "18S","distance.qza"))

# Extract distance matrix
distance_matrix <- distance$data

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

##----Run individual PERMANOVAs-------------------------------------------------------------

# PERMANOVA for CTD vs. ESP
ESP_CTD_permanova_18S <- adonis2(PCA_dist ~ CTD_or_ESP, data = pca_metadata, permutations=999)

# PERMANOVA for depth
depth_permanova_18S <- adonis2(PCA_dist ~ depth_cat, data = pca_metadata, permutations=999)

# PERMANOVA for seasonality (cruise)
season_permanova_18S <- adonis2(PCA_dist ~ SAMPLING_cruise, data = pca_metadata, permutations=999)

##----Run multi-factor PERMANOVAs-------------------------------------------------------------

# Multi-factorial PERMANOVA
mutli_permanova_18S <- adonis2(PCA_dist ~  shallow_deep + SAMPLING_cruise + CTD_or_ESP, data = pca_metadata, permutations=999)

# Save permanova value for plot - ESP vs. CTD after controlling for depth and cruise
permanova_value <- mutli_permanova_18S$`Pr(>F)`[3]
```

### Plot 18S DEICODE RPCA
```{r}
# Set figure directory
fig_dir <- here::here("resubmission")

pco <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "18S","ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_18S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_18S_PCA <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ESP_CTD_18S_PCA

ggsave(path = fig_dir, filename = "ESP_CTD_18S_PCA.png", ESP_CTD_18S_PCA,width = 7,height = 5)
```

### Plot 18S DEICODE RPCA - pairs labeled
```{r}
# Set figure directory
fig_dir <- here::here("resubmission")

pco <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "18S","ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_18S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_18S_PCA_pairs_labeled <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  geom_line(lty = 2, aes(group = matching_ID)) +
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ESP_CTD_18S_PCA

ggsave(path = fig_dir, filename = "ESP_CTD_18S_PCA_pairs_labeled.png", ESP_CTD_18S_PCA_pairs_labeled,width = 7,height = 5)
```


# 12S

### Prep data for DEICODE
```{r}
# Set directory for saving DEICODE data
deicode_dir <- here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "12S")

# Subset environmental samples for comparison
ESP_CTD_12S_envt_phyloseq <- prune_samples(sample_data(ESP_CTD_12S_phyloseq)$CTD_or_ESP %in% c("CTD","ESP"),ESP_CTD_12S_phyloseq)
ESP_CTD_12S_envt_phyloseq <- prune_taxa(taxa_sums(ESP_CTD_12S_envt_phyloseq) > 0, ESP_CTD_12S_envt_phyloseq)

ESP_CTD_12S_envt_asv_table <- as.data.frame(as(otu_table(ESP_CTD_12S_envt_phyloseq),"matrix"))
ESP_CTD_12S_envt_asv_table <- tibble::rownames_to_column(ESP_CTD_12S_envt_asv_table,"#OTUID")
write.table(ESP_CTD_12S_envt_asv_table, paste0(deicode_dir, "/ESP_CTD_12S_envt_asv_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_12S_envt_tax_table <- as.data.frame(as(tax_table(ESP_CTD_12S_envt_phyloseq),"matrix"))
ESP_CTD_12S_envt_tax_table <- tibble::rownames_to_column(ESP_CTD_12S_envt_tax_table,"#OTUID")
write.table(ESP_CTD_12S_envt_tax_table, paste0(deicode_dir, "/ESP_CTD_12S_envt_tax_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_12S_envtsamples_metadata <- as.data.frame(as.matrix(sample_data(ESP_CTD_12S_envt_phyloseq)))
ESP_CTD_12S_envtsamples_metadata <- tibble::rownames_to_column(ESP_CTD_12S_envtsamples_metadata,"#SampleID")
# Add a categorical depth field to the metadata
ESP_CTD_12S_envtsamples_metadata %>%
  mutate(depth = as.numeric(depth)) %>%
  mutate(depth_cat = ifelse(depth <= 25.5, "0-25",
                            ifelse(depth <= 50, "27-50",
                                   ifelse(depth <= 201 & depth >=195, "195-200",
                                          "unknown")))) %>% 
  # Make another, simplified depth category (shallow_deep) 
  mutate(shallow_deep = ifelse(depth_cat %in% c("0-25", "27-50"), "shallow", "deep")) -> ESP_CTD_12S_envtsamples_metadata
write.table(ESP_CTD_12S_envtsamples_metadata, paste0(deicode_dir, "/ESP_CTD_12S_envt_sample_data_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
```


### Run DEICODE in Qiime2

```{bash, engine.opts = '-l', eval = FALSE}
# Enter qiime2 environment
conda activate qiime2-2020.11


#Make biom file
biom convert -i ../DEICODE/resubmission/12S/ESP_CTD_12S_envt_asv_table_for_biom.txt -o ../DEICODE/resubmission/12S/table.from_txt_json.biom --table-type="OTU table" --to-json
#add metadata files to biom file
biom add-metadata -i ../DEICODE/resubmission/12S/table.from_txt_json.biom -o ../DEICODE/resubmission/12S/table.w_md.biom \
--observation-metadata-fp ../DEICODE/resubmission/12S/ESP_CTD_12S_envt_tax_table_for_biom.txt \
--sample-metadata-fp ../DEICODE/resubmission/12S/ESP_CTD_12S_envt_sample_data_for_biom.txt

#import into Qiime2
qiime tools import \
--input-path ../DEICODE/resubmission/12S/table.w_md.biom \
--output-path ../DEICODE/resubmission/12S/ESP_CTD_12S_master.biom.qza \
--type FeatureTable[Frequency]

#run DEICODE
qiime deicode rpca \
--i-table ../DEICODE/resubmission/12S/ESP_CTD_12S_master.biom.qza \
--p-n-components 3 \
--p-min-feature-count 10 \
--p-min-sample-count 1000 \
--o-biplot ../DEICODE/resubmission/12S/ordination.qza \
--o-distance-matrix ../DEICODE/resubmission/12S/distance.qza
```


### Run PERMANOVA
```{r }
# Extract metadata
pca_metadata <- ESP_CTD_12S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load 12S Data
distance <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "12S","distance.qza"))

# Extract distance matrix
distance_matrix <- distance$data

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

##----Run individual PERMANOVAs-------------------------------------------------------------

# PERMANOVA for CTD vs. ESP
ESP_CTD_permanova_12S <- adonis2(PCA_dist ~ CTD_or_ESP, data = pca_metadata, permutations=999)

# PERMANOVA for depth
depth_permanova_12S <- adonis2(PCA_dist ~ depth_cat, data = pca_metadata, permutations=999)

# PERMANOVA for seasonality (cruise)
season_permanova_12S <- adonis2(PCA_dist ~ SAMPLING_cruise, data = pca_metadata, permutations=999)

##----Run multi-factor PERMANOVAs-------------------------------------------------------------

# Multi-factorial PERMANOVA
mutli_permanova_12S <- adonis2(PCA_dist ~  shallow_deep + SAMPLING_cruise + CTD_or_ESP, data = pca_metadata, permutations=999)

# Save permanova value for plot - ESP vs. CTD after controlling for depth and cruise
permanova_value <- mutli_permanova_12S$`Pr(>F)`[3]
```


### Plot 12S DEICODE RPCA
```{r}
# Set figure directory
fig_dir <- here::here("resubmission")

pco <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "12S","ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_12S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_12S_PCA <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ESP_CTD_12S_PCA

ggsave(path = fig_dir, filename = "ESP_CTD_12S_PCA.png", ESP_CTD_12S_PCA,width = 7,height = 5)
```


### Plot 12S DEICODE RPCA - pairs labeled
```{r}
# Set figure directory
fig_dir <- here::here("resubmission")

pco <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "12S","ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_12S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_12S_PCA_pairs_labeled <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  geom_line(lty = 2, aes(group = matching_ID)) +
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ESP_CTD_12S_PCA_pairs_labeled

ggsave(path = fig_dir, filename = "ESP_CTD_12S_PCA_pairs_labeled.png", ESP_CTD_12S_PCA_pairs_labeled,width = 7,height = 5)
```

# 16S

### Prep data for DEICODE
```{r}
# Set directory for saving DEICODE data
deicode_dir <- here::here("16S_Analyses", "DEICODE", "resubmission")

# Subset environmental samples for comparison
ESP_CTD_16S_envt_phyloseq <- prune_samples(sample_data(ESP_CTD_16S_phyloseq)$CTD_or_ESP %in% c("CTD","ESP"),ESP_CTD_16S_phyloseq)
ESP_CTD_16S_envt_phyloseq <- prune_samples(sample_sums(ESP_CTD_16S_envt_phyloseq) > 1000, ESP_CTD_16S_envt_phyloseq)
ESP_CTD_16S_envt_phyloseq <- prune_taxa(taxa_sums(ESP_CTD_16S_envt_phyloseq) > 0, ESP_CTD_16S_envt_phyloseq)

ESP_CTD_16S_envt_asv_table <- as.data.frame(as(otu_table(ESP_CTD_16S_envt_phyloseq),"matrix"))
ESP_CTD_16S_envt_asv_table <- tibble::rownames_to_column(ESP_CTD_16S_envt_asv_table,"#OTUID")
write.table(ESP_CTD_16S_envt_asv_table, paste0(deicode_dir, "/ESP_CTD_16S_envt_asv_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_16S_envt_tax_table <- as.data.frame(as(tax_table(ESP_CTD_16S_envt_phyloseq),"matrix"))
ESP_CTD_16S_envt_tax_table <- tibble::rownames_to_column(ESP_CTD_16S_envt_tax_table,"#OTUID")
write.table(ESP_CTD_16S_envt_tax_table,paste0(deicode_dir, "/ESP_CTD_16S_envt_tax_table_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
ESP_CTD_16S_envtsamples_metadata <- as.data.frame(as.matrix(sample_data(ESP_CTD_16S_envt_phyloseq)))
ESP_CTD_16S_envtsamples_metadata <- tibble::rownames_to_column(ESP_CTD_16S_envtsamples_metadata,"#SampleID")
# Add a categorical depth field to the metadata
ESP_CTD_16S_envtsamples_metadata$depth <- extract_numeric(ESP_CTD_16S_envtsamples_metadata$Depth)
ESP_CTD_16S_envtsamples_metadata %>%
  mutate(depth = as.numeric(depth)) %>%
  mutate(depth_cat = ifelse(depth <= 25.5, "0-25",
                            ifelse(depth <= 50, "27-50",
                                   ifelse(depth <= 201 & depth >=195, "195-200",
                                          "unknown")))) %>% 
  # Make another, simplified depth category (shallow_deep) 
  mutate(shallow_deep = ifelse(depth_cat %in% c("0-25", "27-50"), "shallow", "deep")) -> ESP_CTD_16S_envtsamples_metadata
write.table(ESP_CTD_16S_envtsamples_metadata, paste0(deicode_dir, "/ESP_CTD_16S_envt_sample_data_for_biom.txt"),sep = "\t",row.names = FALSE,quote = FALSE)
```


### Run DEICODE in Qiime2

```{bash, engine.opts = '-l', eval = FALSE}
# Enter qiime2 environment
conda activate qiime2-2020.11
pwd
#Make biom file
biom convert -i ../16S_Analyses/DEICODE/resubmission/ESP_CTD_16S_envt_asv_table_for_biom.txt -o ../16S_Analyses/DEICODE/resubmission/table.from_txt_json.biom --table-type="OTU table" --to-json
#add metadata files to biom file
biom add-metadata -i ../16S_Analyses/DEICODE/resubmission/table.from_txt_json.biom -o ../16S_Analyses/DEICODE/resubmission/table.w_md.biom \
--observation-metadata-fp ../16S_Analyses/DEICODE/resubmission/ESP_CTD_16S_envt_tax_table_for_biom.txt \
--sample-metadata-fp ../16S_Analyses/DEICODE/resubmission/ESP_CTD_16S_envt_sample_data_for_biom.txt

#import into Qiime2
qiime tools import \
--input-path ../16S_Analyses/DEICODE/resubmission/table.w_md.biom \
--output-path ../16S_Analyses/DEICODE/resubmission/ESP_CTD_16S_master.biom.qza \
--type FeatureTable[Frequency]

#run DEICODE
qiime deicode rpca \
--i-table ../16S_Analyses/DEICODE/resubmission/ESP_CTD_16S_master.biom.qza \
--p-n-components 3 \
--p-min-feature-count 10 \
--p-min-sample-count 1000 \
--o-biplot ../16S_Analyses/DEICODE/resubmission/ordination.qza \
--o-distance-matrix ../16S_Analyses/DEICODE/resubmission/distance.qza
```

### Run PERMANOVA
```{r }
# Extract metadata
pca_metadata <- ESP_CTD_16S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load 16S Data
distance <- read_qza(here::here("16S_Analyses", "DEICODE", "resubmission", "distance.qza"))

# Extract distance matrix
distance_matrix <- distance$data

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

##----Run individual PERMANOVAs-------------------------------------------------------------

# PERMANOVA for CTD vs. ESP
ESP_CTD_permanova_16S <- adonis2(PCA_dist ~ CTD_or_ESP, data = pca_metadata, permutations=999)

# PERMANOVA for depth
depth_permanova_16S <- adonis2(PCA_dist ~ depth_cat, data = pca_metadata, permutations=999)

# PERMANOVA for seasonality (cruise)
season_permanova_16S <- adonis2(PCA_dist ~ SAMPLING_cruise, data = pca_metadata, permutations=999)

##----Run multi-factor PERMANOVAs-------------------------------------------------------------

# Multi-factorial PERMANOVA
mutli_permanova_16S <- adonis2(PCA_dist ~  shallow_deep + SAMPLING_cruise + CTD_or_ESP, data = pca_metadata, permutations=999)

# Save permanova value for plot - ESP vs. CTD after controlling for depth and cruise
permanova_value <- mutli_permanova_16S$`Pr(>F)`[3]
```


### Plot 16S DEICODE RPCA
```{r}
pco <- read_qza(here::here("16S_Analyses", "DEICODE", "resubmission", "ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_16S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Extract depth data
pca_data$depth <- extract_numeric(pca_data$Depth)

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_16S_PCA <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ESP_CTD_16S_PCA

ggsave(path = fig_dir, filename = "ESP_CTD_16S_PCA.png", ESP_CTD_16S_PCA,width = 7,height = 5)
```


### Plot 16S DEICODE RPCA - pairs labeled
```{r}
pco <- read_qza(here::here("16S_Analyses", "DEICODE", "resubmission", "ordination.qza"))

label.PC1 <- paste0("PC1 (", round(pco$data$ProportionExplained$PC1, 3)*100,"%)")
label.PC1
label.PC2 <- paste0("PC2 (", round(pco$data$ProportionExplained$PC2, 3)*100,"%)")
label.PC2
label.PC3 <- paste0("PC3 (", round(pco$data$ProportionExplained$PC3, 3)*100,"%)")
label.PC3

## Prepare PCA data for ggplot

pca_metadata <- ESP_CTD_16S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
pca_data <- pco$data$Vectors
pca_data <- right_join(pca_data,pca_metadata,on = "SampleID")
pca_data <- subset(pca_data, !(is.na(pca_data$PC1)))

# Extract depth data
pca_data$depth <- extract_numeric(pca_data$Depth)

# Shape guide for depths
# depth_shapes <- c("0-25" = 21, "27-50" = 22, "195-200" = 24)
cruise_colors <- c("CN18F" = "#ff7f00", "CN18S" = "#1f78b4")
CTD_ESP_shapes <- c("CTD" = 21, "ESP" = 24)
# CTD_ESP_colors = c("CTD" = "#ff7f00", "ESP" = "#1f78b4")

##----Make plot-----------------------------------------------------------------

ESP_CTD_16S_PCA_pairs_labeled <- ggplot(pca_data,aes(x=PC1,y=PC2,color = SAMPLING_cruise, fill = SAMPLING_cruise, shape = CTD_or_ESP))+
  # Make fill for geom point be white if depth is deep; if depth is shallow, then fill with season
  geom_point(size = 5, stroke = 2, fill = ifelse(pca_data$depth_cat %in% c("195-200"), "white", 
                                     ifelse(pca_data$SAMPLING_cruise == "CN18F", "#ff7f00", "#1f78b4")))+
  geom_line(lty = 2, aes(group = matching_ID)) +
  xlab(print(label.PC1))+
  ylab(print(label.PC2))+
  scale_color_manual(values = cruise_colors)+
  scale_fill_manual(values = cruise_colors)+
  scale_shape_manual(values = CTD_ESP_shapes)+
  theme(panel.background = element_rect(fill = "white",size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_blank(),
        axis.ticks.length=unit(0.25, "cm"),
        axis.ticks=element_blank(),
        plot.margin = margin(0.25, 0.25, 0.25, 0.25, "cm"),
        axis.line.x.bottom = element_line(color = "black", size = 1),
        axis.line.y.left = element_line(color = "black", size = 1),
        legend.position = "none")+
  ylim(min(pca_data$PC2)-abs(max(pca_data$PC2)-min(pca_data$PC2))/30, max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/12)
# +
#   annotate(geom = "text", x = max(pca_data$PC1), y = max(pca_data$PC2)+abs(max(pca_data$PC2)-min(pca_data$PC2))/15, label = paste0("PERMANOVA (Autonomous vs. Shipboard), p = ",permanova_value), hjust = 1, size = 5)

ESP_CTD_16S_PCA_pairs_labeled

ggsave(path = fig_dir, filename = "ESP_CTD_16S_PCA_pairs_labeled.png", ESP_CTD_16S_PCA_pairs_labeled,width = 7,height = 5)
```


# Create a legend manually
```{r}
PCA_legend <- ggplot(pca_data) +
  # ESP vs. CTD
  annotate("text",label = "Sampling Method", x = 0, y = 2.8,size = 10,adj = 0)+ # Title ESP or CTD
  annotate("point", x = 0.2, y = 0.9, shape = 21, colour = "black", fill = "black", size = 7, stroke = 3)+ # CTD
  annotate("text",label = "Shipboard", x = 0.6, y = 0.9,size = 7.5,adj = 0)+ #CTD
  annotate("point", x = 0.2, y = 1.9, shape = 24, colour = "black", fill = "black", size = 6, stroke = 3)+ # ESP
  annotate("text",label = "Autonomous", x = 0.6, y = 1.9,size = 7.5,adj = 0)+ #ESP
  # Season and depth
  annotate("text",label = "Season/Depth", x = 6.1, y = 2.8,size = 10,adj = 0)+ # Title 
  annotate("point", x = 7, y = 2, shape = 21, colour = "#ff7f00", fill = "#ff7f00", size = 7, stroke = 3)+ # circle point
  annotate("text",label = "/", x = 6.6, y = 2.01,size = 12,adj = 0, fontface = "bold")+ # slash
  annotate("point", x = 6.3, y = 1.95, shape = 24, colour = "#ff7f00", fill = "#ff7f00", size = 6, stroke = 3)+ # triangle point
  annotate("text",label = "Fall (shallow)", x = 7.3, y = 2,size = 7.5,adj = 0)+ # fall (shallow)
  annotate("point", x = 7, y = 1.2, shape = 21, colour = "#1f78b4", fill = "#1f78b4", size = 7, stroke = 3)+ # circle point
  annotate("text",label = "/", x = 6.6, y = 1.21,size = 12,adj = 0, fontface = "bold")+ # slash
  annotate("point", x = 6.3, y = 1.15, shape = 24, colour = "#1f78b4", fill = "#1f78b4", size = 6, stroke = 3)+ # triangle point
  annotate("text",label = "Spring (shallow)", x = 7.3, y = 1.2,size = 7.5,adj = 0)+ # spring (shallow)
  annotate("point", x = 7, y = 0.4, shape = 21, colour = "#1f78b4", fill = "white", size = 7, stroke = 3)+ # circle point
  annotate("text",label = "/", x = 6.6, y = 0.351,size = 12,adj = 0, fontface = "bold")+ # slash
  annotate("point", x = 6.3, y = 0.35, shape = 24, colour = "#1f78b4", fill = "white", size = 6, stroke = 3)+ # triangle point
  annotate("text",label = "Spring (deep)", x = 7.3, y = 0.4,size = 7.5,adj = 0)+ # spring (deep)
  
  
  xlim(0,10)+
  ylim(0.2,3.2)+
    theme(panel.background = element_rect(fill="white"),
        panel.border = element_rect(colour = "black", fill=NA, size=2),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(), 
        legend.position = "none",
        plot.margin = unit(c(0,10,0,10),"cm"))
```

# Combine all PCA figures
```{r}
combined_PCA_gg <- ggpubr::ggarrange(ggpubr::ggarrange(ESP_CTD_18S_PCA, 
                                                 ESP_CTD_COI_PCA, ESP_CTD_12S_PCA, ESP_CTD_16S_PCA, ncol = 2, nrow = 2,
                                                 labels = c("(a) 18S", "(b) COI", "(c) 12S", "(d) 16S"), label.x = 0.05, label.y = 0.985,
                                                 font.label = list(size = 35, color = "black", face = "bold"), hjust = -0.12),
                                                 PCA_legend, nrow = 2, ncol = 1, heights = c(7,1))

# Reorder according to organism size

combined_PCA_gg <- ggpubr::ggarrange(ggpubr::ggarrange(ESP_CTD_16S_PCA, 
                                                 ESP_CTD_18S_PCA, ESP_CTD_COI_PCA, ESP_CTD_12S_PCA, ncol = 2, nrow = 2,
                                                 labels = c("(a) 16S", "(b) 18S", "(c) COI", "(d) 12S"), label.x = 0.05, label.y = 0.985,
                                                 font.label = list(size = 35, color = "black", face = "bold"), hjust = -0.12),
                                                 PCA_legend, nrow = 2, ncol = 1, heights = c(7,1))
                                   


ggsave(combined_PCA_gg, height = 16, width = 16, path = fig_dir, filename = "combined_PCA_fig.png", device = "png")

```

# Combine all PCA figures - pairs labeled
```{r}
combined_PCA_pairs_labeled_gg <- ggpubr::ggarrange(ggpubr::ggarrange(ESP_CTD_18S_PCA_pairs_labeled, 
                                                 ESP_CTD_COI_PCA_pairs_labeled, ESP_CTD_12S_PCA_pairs_labeled, ESP_CTD_16S_PCA_pairs_labeled, ncol = 2, nrow = 2,
                                                 labels = c("(a) 18S", "(b) COI", "(c) 12S", "(d) 16S"), label.x = 0.05, label.y = 0.985,
                                                 font.label = list(size = 35, color = "black", face = "bold"), hjust = -0.12),
                                                 PCA_legend, nrow = 2, ncol = 1, heights = c(7,1))

# Reorder according to organism size

combined_PCA_pairs_labeled_gg <- ggpubr::ggarrange(ggpubr::ggarrange(ESP_CTD_16S_PCA_pairs_labeled, 
                                                 ESP_CTD_18S_PCA_pairs_labeled, ESP_CTD_COI_PCA_pairs_labeled, ESP_CTD_12S_PCA_pairs_labeled, ncol = 2, nrow = 2,
                                                 labels = c("(a) 16S", "(b) 18S", "(c) COI", "(d) 12S"), label.x = 0.05, label.y = 0.985,
                                                 font.label = list(size = 35, color = "black", face = "bold"), hjust = -0.12),
                                                 PCA_legend, nrow = 2, ncol = 1, heights = c(7,1))
                                   


ggsave(combined_PCA_pairs_labeled_gg, height = 16, width = 16, path = fig_dir, filename = "combined_PCA_fig_pairs_labeled.png", device = "png")

```

# Combine all PERMANOVA results, export as two tables

### Table of multi-factor PERMANOVA results
```{r}
Dataset <- c(rep("18S",3), rep("COI",3),  rep("12S",3), rep("16S",3))
Variable_tested <- c(rep(c("Sampling method (ESP vs CTD)", "Season (fall vs spring)","Depth groups (0-25, 27-50, 70-200)"),4))
p_value <- c(mutli_permanova_18S$`Pr(>F)`[3], mutli_permanova_18S$`Pr(>F)`[2], mutli_permanova_18S$`Pr(>F)`[1],
             mutli_permanova_COI$`Pr(>F)`[3], mutli_permanova_COI$`Pr(>F)`[2], mutli_permanova_COI$`Pr(>F)`[1],
             mutli_permanova_12S$`Pr(>F)`[3], mutli_permanova_12S$`Pr(>F)`[2], mutli_permanova_12S$`Pr(>F)`[1],
             mutli_permanova_16S$`Pr(>F)`[3], mutli_permanova_16S$`Pr(>F)`[2], mutli_permanova_16S$`Pr(>F)`[1])
F_statistic <- c(mutli_permanova_18S$F[3], mutli_permanova_18S$F[2], mutli_permanova_18S$F[1],
                 mutli_permanova_COI$F[3], mutli_permanova_COI$F[2], mutli_permanova_COI$F[1],
                 mutli_permanova_12S$F[3], mutli_permanova_12S$F[2], mutli_permanova_12S$F[1],
                 mutli_permanova_16S$F[3], mutli_permanova_16S$F[2], mutli_permanova_16S$F[1])
multi_PERMANOVA_results_table <- data.frame(Dataset, Variable_tested, p_value, F_statistic)

write.csv(multi_PERMANOVA_results_table, here::here("resubmission", "TableS3_2021-11-29.csv"))
```

# Pairwise comparisons

## Write functions that will be used for each marker

### Data prep/reformatting function
This function returns a dataframe that contains distances for each pair of samples as well as the relationship between the two samples in terms of their cruise, depth, and whether or not they were paired samples
```{r}
distance_data_prep <- function(metadata, distance) {
  # Extract metadata
  pca_metadata <- metadata
  pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata
  
  # Extract distance matrix
  distance_matrix <- distance$data
  
  # Convert distance matrix into a df of each pair
  distance_matrix %>%
    as.matrix() %>%
    as.data.frame() %>%
    rownames_to_column("Sample1") %>%
    pivot_longer(., cols = colnames(.[2:ncol(.)]), names_to = "Sample2") %>%
    dplyr::rename(distance = value) -> distances_long
  
  ggplot(distances_long, aes(x = distance)) +
    geom_histogram()
  
  # Reformat metadata
  pca_metadata %>%
    dplyr::rename(Sample1 = SampleID) %>%
    # Mutate to reduce three depth categories into shallow vs. deep
    mutate(deep_shallow = ifelse(depth_cat == "195-200", "Deep", "Shallow")) %>%
    dplyr::select(Sample1, SAMPLING_cruise, deep_shallow, matching_ID, CTD_or_ESP) %>%
    dplyr::rename(
      SAMPLING_cruise_1 = SAMPLING_cruise,
      depth_cat_1 = deep_shallow,
      matching_ID_1 = matching_ID,
      CTD_or_ESP_1 = CTD_or_ESP
    ) -> metadata_sample1
  
  pca_metadata %>%
    dplyr::rename(Sample2 = SampleID) %>%
    dplyr::select(Sample2, SAMPLING_cruise, depth_cat, matching_ID, CTD_or_ESP) %>%
    # Mutate to reduce three depth categories into shallow vs. deep
    mutate(deep_shallow = ifelse(depth_cat == "195-200", "Deep", "Shallow")) %>%
    dplyr::rename(
      SAMPLING_cruise_2 = SAMPLING_cruise,
      depth_cat_2 = deep_shallow,
      matching_ID_2 = matching_ID,
      CTD_or_ESP_2 = CTD_or_ESP
    ) -> metadata_sample2
  
  
  # Add metadata
  distances_long %>%
    left_join(., metadata_sample1, by = "Sample1") %>%
    left_join(., metadata_sample2, by = "Sample2") %>%
    # Create new fields to show within vs. among group differences
    mutate(
      same_cruise = ifelse(
        SAMPLING_cruise_1 == SAMPLING_cruise_2,
        "Same Cruise",
        "Different Cruise"
      ),
      same_depth = ifelse(depth_cat_1 == depth_cat_2, "Same Depth", "Different Depth"),
      paired = ifelse(matching_ID_1 == matching_ID_2, "Paired", "Not paired"),
      # Depth and cruise combined
      same_cruise_depth = ifelse(
        same_cruise == "Same Cruise" &
          same_depth == "Same Depth",
        "Same Cruise, Same Depth",
        ifelse(
          same_cruise == "Same Cruise" &
            same_depth == "Different Depth",
          "Same Cruise, Different Depth",
          ifelse(
            same_cruise == "Different Cruise" &
              same_depth == "Same Depth",
            "Different Cruise, Same Depth",
            ifelse(
              same_cruise == "Different Cruise" &
                same_depth == "Different Depth",
              "Different Cruise, Different Depth",
              NA
            )
          )
        )
      )
    ) %>%
    # Remove all zero distances (comparing sample to itself) %>%
    subset(distance != 0) %>%
    # Remove all duplicate distances (i.e., sample 1 and sample 2 vs. sample 2 and sample 1)
    filter(duplicated(distance) == FALSE) -> distances_metadata
  
  return(distances_metadata)
  
}
```


### Plotting function
This function plots histograms of pairwise distances by cruise, depth, and paired vs. not paired.

```{r}
# Create a function to plot histogram based on input data and variable of interest
distance_histogram <- function(input_data, variable){
  # Store colors
  if (variable == "same_cruise_depth"){
    color_values = c("#a6cee3", "#1f78b4", "#b2df8a", "#33a02c")
  }
  else {
    color_values = c("gray80", "gray20")
  }
  
  # Store legend title
  if (variable == "same_cruise_depth"){
    legend_title = "Cruise & Depth"
  }
  else if (variable == "paired"){
    legend_title = "Paired"
  }
  else {
    legend_title = "not using these!"
  }
  
  
  histogram <- ggplot(data = input_data, aes_string(x = "distance", fill = variable))+
    geom_histogram(bins = 100) +
    scale_fill_manual(values = color_values, name = legend_title) +
    theme(panel.background = element_rect(fill ="white", color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "none") +
    scale_x_continuous(limits = c(0,max(input_data$distance+0.1)), oob = scales::oob_keep, expand = c(0,0)) +
    xlab("Aitchison Distance") +
    # scale_y_continuous(limits = c(0, 70), expand = c(0,0))
    scale_y_continuous(expand = expansion(mult = c(0, .05)))
  return(histogram)
}
```



## COI

### Reformat data
```{r}
distance_COI <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "COI","distance.qza"))

distances_metadata_COI <- distance_data_prep(metadata = ESP_CTD_COI_envtsamples_metadata, distance = distance_COI)
```



### Create figures

Make a single column figure, multiple panels. Same x-axis on each panel.
Split the data so that you have all paired samples, samples from the same depth, samples from the same cruise.
```{r}
paired_histogram_COI <- distance_histogram(input_data = distances_metadata_COI, variable = "paired")
cruise_histogram_COI <- distance_histogram(input_data = distances_metadata_COI, variable = "same_cruise")
depth_histogram_COI <- distance_histogram(input_data = distances_metadata_COI, variable = "same_depth")
cruise_depth_histogram_COI <- distance_histogram(input_data = distances_metadata_COI, variable = "same_cruise_depth")

COI_histograms <- egg::ggarrange(paired_histogram_COI, cruise_depth_histogram_COI,
          ncol = 1)

ggsave(here("resubmission", "distance_histograms", "COI_histograms.pdf"), COI_histograms,  height = 5, width = 6)
```

### Run ANOVA

Here we will be running an ANOVA on pairwise distances, rather than a PERMANOVA.

In this ANOVA we will test three variables: 
1) paired vs. not paired
2) same cruise vs. not same cruise
3) same depth vs. not same depth

```{r}
# Run PERMANOVA

# Extract metadata
pca_metadata <- ESP_CTD_COI_envtsamples_metadata
# pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load COI Data
distance <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "COI","distance.qza"))

# Extract distance matrix
distance_matrix <- as.matrix(distance$data)
dput(distance_matrix)

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

# Multi-factorial PERMANOVA
multi_permanova_COI <- adonis2(PCA_dist ~ shallow_deep + SAMPLING_cruise + matching_ID, data = pca_metadata, permutations=999)

# Here the issue is that each pair of samples is treated as a separate group, which isn't as interesting for our analysis

# Run ANOVA

# Test assumptions

# Check normality assumption
lm_COI  <- lm(distance ~ same_cruise + same_depth + paired, data = distances_metadata_COI)
# Create a QQ plot of residuals
ggqqplot(residuals(lm_COI))
# Compute Shapiro-Wilk test of normality
shapiro_test(residuals(lm_COI))
# Horribly not normal

# log transform, try again
distances_metadata_COI %>% 
  mutate(log_distance = log(distance)) -> distances_metadata_COI
lm_log_COI  <- lm(log_distance ~ same_cruise + same_depth + paired, data = distances_metadata_COI)
# Create a QQ plot of residuals
ggqqplot(residuals(lm_log_COI))
# Compute Shapiro-Wilk test of normality
shapiro_test(residuals(lm_log_COI))
# Still horribly not normal





# Order matters: control for cruise and depth first

res.aov.COI <- aov(distance ~ same_cruise + same_depth + paired,  data = distances_metadata_COI)
summary(res.aov.COI)

# res.aov.COI <- aov(distance ~ paired + same_depth + same_cruise,  data = distances_metadata_COI)
# summary(res.aov.COI)

```



## 18S

### Reformat data
```{r}
distance_18S <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "18S","distance.qza"))

distances_metadata_18S <- distance_data_prep(metadata = ESP_CTD_18S_envtsamples_metadata, distance = distance_18S)
```



### Create figures

Make a single column figure, multiple panels. Same x-axis on each panel.
Split the data so that you have all paired samples, samples from the same depth, samples from the same cruise.
```{r}
paired_histogram_18S <- distance_histogram(input_data = distances_metadata_18S, variable = "paired")
cruise_histogram_18S <- distance_histogram(input_data = distances_metadata_18S, variable = "same_cruise")
depth_histogram_18S <- distance_histogram(input_data = distances_metadata_18S, variable = "same_depth")
cruise_depth_histogram_18S <- distance_histogram(input_data = distances_metadata_18S, variable = "same_cruise_depth")

histograms_18S <- egg::ggarrange(paired_histogram_18S, cruise_depth_histogram_18S,
                                 ncol = 1)

ggsave(here("resubmission", "distance_histograms", "18S_histograms.pdf"), histograms_18S,  height = 5, width = 6)
```

### Run ANOVA

Here we will be running an ANOVA on pairwise distances, rather than a PERMANOVA.

In this ANOVA we will test three variables: 
  1) paired vs. not paired
2) same cruise vs. not same cruise
3) same depth vs. not same depth

```{r}
# Run PERMANOVA

# Extract metadata
pca_metadata <- ESP_CTD_18S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load 18S Data
distance <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "18S","distance.qza"))

# Extract distance matrix
distance_matrix <- distance$data

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

# Multi-factorial PERMANOVA
multi_permanova_18S <- adonis2(PCA_dist ~ shallow_deep + SAMPLING_cruise + matching_ID, data = pca_metadata, permutations=999)

# Here the issue is that each pair of samples is treated as a separate group, which isn't as interesting for our analysis

# Run ANOVA

# Order matters: control for cruise and depth first

res.aov.18S <- aov(distance ~ same_cruise + same_depth + paired,  data = distances_metadata_18S)
summary(res.aov.18S)

# res.aov.18S <- aov(distance ~ paired + same_depth + same_cruise,  data = distances_metadata_18S)
# summary(res.aov.18S)

```




## 12S

### Reformat data
```{r}
distance_12S <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "12S","distance.qza"))

distances_metadata_12S <- distance_data_prep(metadata = ESP_CTD_12S_envtsamples_metadata, distance = distance_12S)
```



### Create figures

Make a single column figure, multiple panels. Same x-axis on each panel.
Split the data so that you have all paired samples, samples from the same depth, samples from the same cruise.
```{r}
paired_histogram_12S <- distance_histogram(input_data = distances_metadata_12S, variable = "paired")
cruise_histogram_12S <- distance_histogram(input_data = distances_metadata_12S, variable = "same_cruise")
depth_histogram_12S <- distance_histogram(input_data = distances_metadata_12S, variable = "same_depth")
cruise_depth_histogram_12S <- distance_histogram(input_data = distances_metadata_12S, variable = "same_cruise_depth")

histograms_12S <- egg::ggarrange(paired_histogram_12S, cruise_depth_histogram_12S,
                                 ncol = 1)

ggsave(here("resubmission", "distance_histograms", "12S_histograms.pdf"), histograms_12S,  height = 5, width = 6)
```

### Run ANOVA

Here we will be running an ANOVA on pairwise distances, rather than a PERMANOVA.

In this ANOVA we will test three variables: 
  1) paired vs. not paired
2) same cruise vs. not same cruise
3) same depth vs. not same depth

```{r}
# Run PERMANOVA

# Extract metadata
pca_metadata <- ESP_CTD_12S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load 12S Data
distance <- read_qza(here::here("18S_12S_CO1_Analyses", "DEICODE", "resubmission", "12S","distance.qza"))

# Extract distance matrix
distance_matrix <- distance$data

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

# Multi-factorial PERMANOVA
multi_permanova_12S <- adonis2(PCA_dist ~ shallow_deep + SAMPLING_cruise + matching_ID, data = pca_metadata, permutations=999)

# Here the issue is that each pair of samples is treated as a separate group, which isn't as interesting for our analysis

# Run ANOVA

# Order matters: control for cruise and depth first

res.aov.12S <- aov(distance ~ same_cruise + same_depth + paired,  data = distances_metadata_12S)
summary(res.aov.12S)

# res.aov.12S <- aov(distance ~ paired + same_depth + same_cruise,  data = distances_metadata_12S)
# summary(res.aov.12S)

```





## 16S

### Reformat data
```{r}
distance_16S <- read_qza(here::here("16S_Analyses", "DEICODE", "resubmission", "distance.qza"))

distances_metadata_16S <- distance_data_prep(metadata = ESP_CTD_16S_envtsamples_metadata, distance = distance_16S)
```



### Create figures

Make a single column figure, multiple panels. Same x-axis on each panel.
Split the data so that you have all paired samples, samples from the same depth, samples from the same cruise.
```{r}
ggplot(distances_metadata_16S, aes(x = distance))+
  geom_histogram(bins = 100)

paired_histogram_16S <- distance_histogram(input_data = distances_metadata_16S, variable = "paired")
cruise_histogram_16S <- distance_histogram(input_data = distances_metadata_16S, variable = "same_cruise")
depth_histogram_16S <- distance_histogram(input_data = distances_metadata_16S, variable = "same_depth")
cruise_depth_histogram_16S <- distance_histogram(input_data = distances_metadata_16S, variable = "same_cruise_depth")

histograms_16S <- egg::ggarrange(paired_histogram_16S, cruise_depth_histogram_16S,
                                 ncol = 1)

ggsave(here("resubmission", "distance_histograms", "16S_histograms.pdf"), histograms_16S,  height = 5, width = 6)
```

## Combine markers into supplemental figure - four rows, two columns

### Generate the legend
```{r}
distance_histogram_2 <- function(input_data, variable){
  # Store colors
  if (variable == "same_cruise_depth"){
    color_values = c("#a6cee3", "#1f78b4", "#b2df8a", "#33a02c")
  }
  else {
    color_values = c("gray80", "gray20")
  }
  
  # Store legend title
  if (variable == "same_cruise_depth"){
    legend_title = "Cruise & Depth"
  }
  else if (variable == "paired"){
    legend_title = "Paired"
  }
  else {
    legend_title = "not using these!"
  }
  
  
  histogram <- ggplot(data = input_data, aes_string(x = "distance", fill = variable))+
    geom_histogram(bins = 100) +
    scale_fill_manual(values = color_values, name = legend_title) +
    theme(panel.background = element_rect(fill ="white", color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    scale_x_continuous(limits = c(0,max(input_data$distance+0.1)), oob = scales::oob_keep, expand = c(0,0)) +
    xlab("Aitchison Distance") +
    # scale_y_continuous(limits = c(0, 70), expand = c(0,0))
    scale_y_continuous(expand = expansion(mult = c(0, .05)))
  return(histogram)
}

paired_histogram_16S_2 <- distance_histogram_2(input_data = distances_metadata_16S, variable = "paired")
cruise_depth_histogram_16S_2 <- distance_histogram_2(input_data = distances_metadata_16S, variable = "same_cruise_depth")

paired_hist_legend <- ggpubr::get_legend(paired_histogram_16S_2)
paired_hist_legend <- as_ggplot(paired_hist_legend)
cruise_depth_hist_legend <- ggpubr::get_legend(cruise_depth_histogram_16S_2)
cruise_depth_hist_legend <- as_ggplot(cruise_depth_hist_legend)
```


### Plot everything together
```{r}
combined_dist_hist <- egg::ggarrange(paired_histogram_16S, cruise_depth_histogram_16S,
                                     paired_histogram_18S, cruise_depth_histogram_18S,
                                     paired_histogram_COI, cruise_depth_histogram_COI,
                                     paired_histogram_12S, cruise_depth_histogram_12S,
                                     paired_hist_legend, cruise_depth_hist_legend,
                                     nrow = 5, ncol = 2,
                                     labels = c("", "(a) 16S", "", "(b) 18S", "", "(c) COI", "", "(d) 12S", "", ""),
                                                      label.args = list(gp=gpar(font=1, cex = 1.5), x=unit(9.75,"cm"), y=unit(5,"cm"), hjust = 1))

ggsave(here("resubmission", "combined_distance_histogram.pdf"), combined_dist_hist,
       height = 10, width = 8)
```

### Run ANOVA

Here we will be running an ANOVA on pairwise distances, rather than a PERMANOVA.

In this ANOVA we will test three variables: 
1) paired vs. not paired
2) same cruise vs. not same cruise
3) same depth vs. not same depth

```{r}
# Run PERMANOVA

# Extract metadata
pca_metadata <- ESP_CTD_16S_envtsamples_metadata
pca_metadata %>% dplyr::rename(., "SampleID" = "#SampleID") -> pca_metadata

## Load 16S Data
distance <- read_qza(here::here("16S_Analyses", "DEICODE", "resubmission", "distance.qza"))

# Extract distance matrix
distance_matrix <- distance$data

# convert DEICODE matrix to "dist" class object
PCA_dist <- as.dist(distance_matrix)

# Multi-factorial PERMANOVA
multi_permanova_16S <- adonis2(PCA_dist ~ shallow_deep + SAMPLING_cruise + matching_ID, data = pca_metadata, permutations=999)

# Here the issue is that each pair of samples is treated as a separate group, which isn't as interesting for our analysis

# Run ANOVA

# Order matters: control for cruise and depth first

res.aov.16S <- aov(distance ~ same_cruise + same_depth + paired,  data = distances_metadata_16S)
summary(res.aov.16S)

# res.aov.16S <- aov(distance ~ paired + same_depth + same_cruise,  data = distances_metadata_16S)
# summary(res.aov.16S)

```

# Inspect all ANOVA outputs
```{r}
summary(res.aov.COI)
summary(res.aov.18S)
summary(res.aov.12S)
summary(res.aov.16S)
```




# Check pairwise distances by cruise
```{r}
paired_16S_distances <- subset(distances_metadata_16S, paired == "Paired")

t.test(subset(paired_16S_distances, SAMPLING_cruise_1 == "CN18S")$distance,
        subset(paired_16S_distances, SAMPLING_cruise_1 == "CN18F")$distance)

paired_18S_distances <- subset(distances_metadata_18S, paired == "Paired")

t.test(subset(paired_18S_distances, SAMPLING_cruise_1 == "CN18S")$distance,
        subset(paired_18S_distances, SAMPLING_cruise_1 == "CN18F")$distance)

paired_COI_distances <- subset(distances_metadata_COI, paired == "Paired")

t.test(subset(paired_COI_distances, SAMPLING_cruise_1 == "CN18S")$distance,
        subset(paired_COI_distances, SAMPLING_cruise_1 == "CN18F")$distance)

paired_12S_distances <- subset(distances_metadata_12S, paired == "Paired")

t.test(subset(paired_12S_distances, SAMPLING_cruise_1 == "CN18S")$distance,
        subset(paired_12S_distances, SAMPLING_cruise_1 == "CN18F")$distance)
```


# Permutation party!

Here we will compare the mean distance between paired samples to the mean distance between randomly paired samples.

This will be run for each cruise and depth bin.


## Function
We will write a function where the input is the cruise, depth, and marker, and it will run this permutation test.

Inputs:
1) Distance and metadata in one DF (output from distance_data_prep() function)
2) Number of desired permutations

First let's check the mean values (without permutations)
```{r}
# Calculate mean distance between paired samples
distances_metadata_COI %>% 
  subset(SAMPLING_cruise_1 == "CN18F" & SAMPLING_cruise_2 == "CN18F") %>% 
  subset(depth_cat_1 == "Shallow" & depth_cat_2 == "Shallow") %>% 
  subset(paired == "Paired") -> paired_samples_df 

mean(paired_samples_df$distance)

# Calculate mean distance between all samples

distances_metadata_COI %>% 
  subset(SAMPLING_cruise_1 == "CN18F" & SAMPLING_cruise_2 == "CN18F") %>% 
  subset(depth_cat_1 == "Shallow" & depth_cat_2 == "Shallow") %>% 
  subset(paired == "Not paired") -> non_paired_samples_df 

mean(non_paired_samples_df$distance)
```


```{r}
paired_permutation_test <- function(distance_metadata_df, permutations, cruise, depth){
  
distance_metadata_df %>% 
  subset(SAMPLING_cruise_1 == cruise & SAMPLING_cruise_2 == cruise) %>% 
  subset(depth_cat_1 == depth & depth_cat_2 == depth) -> cruise_depth_df

# Get the mean distance between paired samples
actual_mean <- mean(subset(cruise_depth_df, paired == "Paired")$distance)

# Create a vector to store these
random_distances <- vector(length = permutations)


# Get a vector of random distances - same length as permuted variables
for (i in 1:permutations){
  random_distances[i] <- mean(sample(cruise_depth_df$distance, 22, replace = FALSE))
}

# Determine the frequency with which actual mean was less than random mean
p_val <- length(random_distances[actual_mean > random_distances])/length(random_distances)

# Plot a histogram
random_distances %>% 
  as.data.frame() %>% 
  dplyr::rename(distance = ".") -> random_distances_df

permutation_plot <- ggplot(random_distances_df, aes(x = distance)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = actual_mean)

print(paste0("p = ", round(p_val, 3)))

return(permutation_plot)

}


```

### Run the function for each combination of cruise and depth
```{r}
paired_permutation_test(distance_metadata_df = distances_metadata_COI, permutations = 1000, cruise = "CN18F", depth = "Shallow")

markers <- c("COI", "18S", "12S", "16S")
cruises <- c("CN18S", "CN18F")
depths <- c("Shallow", "Deep")

for (i in 1:length(markers)){
  for (j in 1:length(cruises)){
    for (k in 1:length(depths)){
      tryCatch({
        print(paste(markers[i], cruises[j], depths[k]), sep = " ")
      paired_permutation_test(distance_metadata_df = eval(parse(text = paste0("distances_metadata_",markers[i]))), 
                              permutations = 1000, 
                              cruise = cruises[j], 
                              depth = depths[k])
      }, error = function(e){cat("This combination of depth + cruise does not exist \n")})
      
      
    }
  }
}

# Visually inspect the significant cruise + depth + marker combinations

paired_permutation_test(distance_metadata_df = distances_metadata_COI, permutations = 1000, cruise = "CN18S", depth = "Deep")
distance_histogram(input_data = subset(distances_metadata_COI,
                                                               SAMPLING_cruise_1 == "CN18S" &
                                                               SAMPLING_cruise_2 == "CN18S" &
                                                               depth_cat_1 == "Deep" &
                                                               depth_cat_2 == "Deep"),
                                                               variable = "paired")

paired_permutation_test(distance_metadata_df = distances_metadata_16S, permutations = 1000, cruise = "CN18S", depth = "Shallow")

distance_histogram(input_data = subset(distances_metadata_16S,
                                                               SAMPLING_cruise_1 == "CN18S" &
                                                               SAMPLING_cruise_2 == "CN18S" &
                                                               depth_cat_1 == "Shallow" &
                                                               depth_cat_2 == "Shallow"),
                                                               variable = "paired")
# paired_permutation_test(distance_metadata_df = distances_metadata_18S, permutations = 1000, cruise = "CN18F", depth = "Shallow")
```


# Permutation test

Here we will examine if paired samples are significantly more similar than non-paired samples, when you subset just the same cruise and depth samples. This is different than the previous permutation tests in that we aren't looking at each cruise and depth pairing separately. This way, we're significantly increasing the number of samples that can be chosen for the test.

```{r}
paired_permutation_test <- function(distance_metadata_df, permutations){
  
distance_metadata_df %>% 
  subset(same_cruise_depth == "Same Cruise, Same Depth") -> same_cruise_depth_df

# Get the mean distance between paired samples
actual_mean <- mean(subset(same_cruise_depth_df, paired == "Paired")$distance)

# Create a vector to store these
random_distances <- vector(length = permutations)


# Get a vector of random distances - same length as permuted variables
# Get number of pairs
npairs <- dim(subset(same_cruise_depth_df, paired == "Paired"))[1]

for (i in 1:permutations){
  random_distances[i] <- mean(sample(same_cruise_depth_df$distance, npairs, replace = FALSE))
}

# Determine the frequency with which actual mean was less than random mean
p_val <- length(random_distances[actual_mean > random_distances])/length(random_distances)

# Plot a histogram
random_distances %>% 
  as.data.frame() %>% 
  dplyr::rename(distance = ".") -> random_distances_df

permutation_plot <- ggplot(random_distances_df, aes(x = distance)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = actual_mean)

print(paste0("p = ", round(p_val, 3)))

return(permutation_plot)

}

set.seed(123)
paired_permutation_test(distance_metadata_df = distances_metadata_16S, permutations = 1000)
paired_permutation_test(distance_metadata_df = distances_metadata_18S, permutations = 1000)
paired_permutation_test(distance_metadata_df = distances_metadata_COI, permutations = 1000)
paired_permutation_test(distance_metadata_df = distances_metadata_12S, permutations = 1000)
```






